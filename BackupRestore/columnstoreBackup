#!/bin/bash

VERBOSE=false
QUIET=false
COMPRESS=false
INSTALL_DIR=/usr/local/mariadb/columnstore
PM1=none
BACKUP_SERVER_LOCATION=none
DRY_RUN=false
REMOTE_USER=root
NUMBER_BACKUPS=3

if [ -e columnstoreBackup.config ]; then
    source columnstoreBackup.config
fi
REcheck='^[0-9]+$'
if ! [[ $NUMBER_BACKUPS =~ $REcheck ]] ; then
   echo "ERROR: NUMBER_BACKUPS not a number" >&2; exit 1
fi
if [ $NUMBER_BACKUPS -lt 0 ] || [ $NUMBER_BACKUPS -gt 20 ]; then
    echo "ERROR: NUMBER_BACKUPS must be an integer between 1 and 100 (value: $NUMBER_BACKUPS)" >&2
    exit 1
fi

###
# Print Fucntions
###

helpPrint () {
          ################################################################################
    echo ""
    echo "MariaDB ColumnStore Automated Backup Tool"
    echo ""
    echo "This tool is meant to automate the ColumnStore backup procedure documented at:"
    echo ""
    echo "https://mariadb.com/kb/en/mariadb/columnstore-backup-and-recovery/"
    echo ""
    echo "The tool is designed to be run on the system storing the backups. It requires"
    echo "the backup system to have passwordless login enabled for the account that"
    echo "MariaDB ColumnStore was installed and maintained. (Assumes root by default)"
    echo ""
    echo "This tool must be run as root or with sudo."
    echo ""
    echo "The default behavior is to run rsync locally to each UM and PM."
    echo "PM data is stored in data directories labeled pm[moduleID]dbroot[DBrootID]"
    echo "UM data is stored in directories labeled um[moduleID]"
    echo "my.cnf data is stored in directory cnf"
    echo "Columnstore.xml is stored in the top level of backupServerLocation"
    echo ""
    echo "The -n option uses the rsync link-dest option to enable incremental backups."
    echo "These are stored in backup.1 thru backup.[n-1] from newest to oldest."
    echo "The impact on extra space needed is based on the amount data that changes."
    echo "with little to no data set changes the incremental backup size is small."
    echo ""
    echo "Usage: $0 [options] pm1 backupServerLocation"
    echo ""
    echo "pm1                       IP address of ColumnStore server"
    echo "                              (PM1 if Multi-Node install)"
    echo "backupServerLocation      Path to the directory for storing backup files."
    echo ""    
    echo "OPTIONS:"
    echo "-h,--help         Print this message and exit."
    echo "-v,--verbose      Print more verbose execution details." 
    echo "-d,--dry-run      Dry run and executes rsync dry run with stats." 
    echo "-z,--compress     Utilize the compression option for rsync."
    echo "--user=[user]     Change the user performing remote sessions. (Default: root)"
    echo ""
    echo "--install-dir=[PATH]  Change the install directory of ColumnStore."
    echo "                          Default: /usr/local/mariadb/columnstore"
    echo ""
}

verbosePrint () {
    if [ "$VERBOSE" = true ]; then
        echo $1 
    fi
}



# Parse command line options.
while getopts hdzv-: OPT; do
    case "$OPT" in
        h)
            echo $USAGE
            helpPrint
            exit 0
            ;;
        d)
            DRY_RUN=true
            ;;
        z)
            COMPRESS=true
            ;;      
        v)
            VERBOSE=true
            ;;         
        -)  LONG_OPTARG="${OPTARG#*=}"
            ## Parsing hack for the long style of arguments.
            case $OPTARG in
                help )  
                    helpPrint
                    exit 0
                    ;;            
                compress )  
                    COMPRESS=true 
                    ;;
                dry-run )
                    DRY_RUN=true
                    ;;   
                verbose)
                    VERBOSE=true
                    ;;                    
                install-dir=?* )  
                    INSTALL_DIR="$LONG_OPTARG" 
                    ;;
                user=?* )  
                    REMOTE_USER="$LONG_OPTARG" 
                    ;;                    
                install-dir* )  
                    echo "No arg for --$OPTARG option" >&2
                    exit 1
                    ;;
                user* )  
                    echo "No arg for --$OPTARG option" >&2
                    exit 1
                    ;;
                help* )  
                    helpPrint
                    exit 0
                    ;;                                        
                compress* )
                    echo "No arg allowed for --$OPTARG option" >&2
                    exit 1 
                    ;;
                dry-run* )
                    echo "No arg allowed for --$OPTARG option" >&2
                    exit 1
                    ;;      
                verbose* )
                    echo "No arg allowed for --$OPTARG option" >&2
                    exit 1
                    ;;                    
                '' )
                    break ;; # "--" terminates argument processing
                * )
                    echo "Illegal option --$OPTARG" >&2
                    exit 1
                    ;;
            esac 
            ;;       
        \?)
            # getopts issues an error message
            echo $USAGE >&2
            exit 1
            ;;
    esac
done

# Remove the switches we parsed above.
shift `expr $OPTIND - 1`

# We want 2 non-option argument. 
if [ $# -ne 2 ]; then
    if [ $# -lt 2 ]; then
        echo "Missing arguments." >&2
    fi
    if [ $# -gt 2 ]; then
        echo "Unknown extra arguments." >&2
    fi
    echo $USAGE >&2
    exit 1
fi

## Check if root or sudo
if [[ $EUID -ne 0 ]]; then
   echo "ERROR: This script must be run as root or with sudo" 
   exit 1
fi

## Check rsync and xmllint are available
if ! type rsync > /dev/null; then
    echo "rsync is not installed. Please install and rerun." >&2
    exit 2
fi
if ! type xmllint > /dev/null; then
    echo "xmllint is not installed. Please install and rerun." >&2
    exit 2
fi

#
PM1=$1
BACKUP_SERVER_LOCATION=$2

## setup rsync option lists
rsyncCommand="rsync "
rsyncOptions="-a "
rsyncLongOptions="--delete "
if [ "$COMPRESS" = true ]; then
    rsyncOptions=$rsyncOptions"-z " 
fi
if [ "$VERBOSE" = true ]; then
    rsyncOptions=$rsyncOptions""
    rsyncLongOptions=$rsyncLongOptions""
fi

rsyncCommand="$rsyncCommand$rsyncOptions$rsyncLongOptions"

if ! ssh -q -o "BatchMode yes" $REMOTE_USER@$PM1 ls $INSTALL_DIR > /dev/null; then
    echo "ERROR: Cannot connect to $REMOTE_USER@$PM1" >&2
    echo "Check that ssh and passwordless login are available." >&2
    exit 255
fi

## EX ARG pm1dbroot1
rotateBackups () {
for (( backupNumber=1; backupNumber<=$NUMBER_BACKUPS; backupNumber++ ))
do
    if [ ! -e $BACKUP_SERVER_LOCATION/backup.$backupNumber ]; then
        mkdir $BACKUP_SERVER_LOCATION/backup.$backupNumber
    fi
done

for (( backupNumber=$NUMBER_BACKUPS; backupNumber>=1; backupNumber-- ))
do
    if [ $backupNumber -eq $NUMBER_BACKUPS ]; then
        rm -rf $BACKUP_SERVER_LOCATION/backup.$backupNumber
    else
        mv $BACKUP_SERVER_LOCATION/backup.$backupNumber $BACKUP_SERVER_LOCATION/backup.$(($backupNumber+1))
    fi
done
}

moveBackupFiles () {
moveThis=$1
destPath=$2
if [ ! -e $BACKUP_SERVER_LOCATION/backup.1 ]; then
    mkdir $BACKUP_SERVER_LOCATION/backup.1
fi
if [ "$DRY_RUN" = false ]; then
    if [ -e $BACKUP_SERVER_LOCATION/$moveThis ]; then
        mv $BACKUP_SERVER_LOCATION/$moveThis $BACKUP_SERVER_LOCATION/$destPath
    fi
fi
}

executeRsync () {
dryRunFlag=$1
extraOptions=$2
source=$3
dest=$4

## setup rsync option lists
if [ "$dryRunFlag" = true ]; then
    extraOptions="-n --stats "$extraOptions
fi

command="$rsyncCommand $extraOptions $source $dest"


if [ "$dryRunFlag" = false ]; then
    verbosePrint "$command"
    if ! $command; then
        echo "ERROR: Rsync command failed." >&2
        echo "ERROR Command: $command" >&2
        exit 4
    fi
else
    echo "$command"
    $command    
fi
}

executeRsyncBackground () {
dryRunFlag=$1
resultsDir=$2
extraOptions=$3
source=$4
dest=$5

## setup rsync option lists
if [ "$dryRunFlag" = true ]; then
    extraOptions="-n --stats "$extraOptions
fi

command="$rsyncCommand $extraOptions $source $dest"

if [ "$dryRunFlag" = false ]; then
    verbosePrint "$command"
    { $command ; echo "$?" > "$resultsDir" ; } &
else
    echo "$command"
    $command
fi
}

waitRsyncBackground () {
dataSize=$1
dir=$2
if [ "$DRY_RUN" = false ]; then
    echo "Waiting for backups to complete..."
    monitorProgress $dataSize $dataLocation
    wait
    for file in "$dir"/*; do
        if [ $(<"$file") != 0 ]; then
            echo "ERROR: RSYNC failed $file with Error: $(<"$file")" >&2
            echo "Backup may not be usable." >&2
            rm -r "$dir"                       
            exit 6
        fi
    done
fi
}

###############################################################################
# Get the system info from provided PM1
###############################################################################
getSystemInfo () {
# Go grab PM1's columnstore.xml file and parse it to find out information on system nodes.
moveBackupFiles Columnstore.xml ./backup.1/
executeRsync false --link-dest=./backup.1 $REMOTE_USER@$PM1:$INSTALL_DIR/etc/Columnstore.xml $BACKUP_SERVER_LOCATION 

moveBackupFiles releasenum ./backup.1/
executeRsync false --link-dest=./backup.1 $REMOTE_USER@$PM1:$INSTALL_DIR/releasenum $BACKUP_SERVER_LOCATION

## parse it
systemName=$(xmllint --xpath 'string(//SystemName)' $BACKUP_SERVER_LOCATION/Columnstore.xml)
singleServerInstall=$(xmllint --xpath 'string(//SingleServerInstall)' $BACKUP_SERVER_LOCATION/Columnstore.xml)
serverTypeInstall=$(xmllint --xpath 'string(//ServerTypeInstall)' $BACKUP_SERVER_LOCATION/Columnstore.xml)
PMwithUM=$(xmllint --xpath 'string(//PMwithUM)' $BACKUP_SERVER_LOCATION/Columnstore.xml)
DBRootStorageType=$(xmllint --xpath 'string(//DBRootStorageType)' $BACKUP_SERVER_LOCATION/Columnstore.xml)

umModuleCount=$(xmllint --xpath "string(//ModuleCount2)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
pmModuleCount=$(xmllint --xpath "string(//ModuleCount3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)

DBRootCount=$(xmllint --xpath 'string(//DBRootCount)' $BACKUP_SERVER_LOCATION/Columnstore.xml)
for (( dbRootID=1; dbRootID<=$DBRootCount; dbRootID++ ))
do
    DBRoot[$dbRootID]=$(xmllint --xpath "string(//DBRoot$dbRootID)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
done

if [ $singleServerInstall == "n" ]; then
    detectError=false
    for (( moduleID=1; moduleID<=$umModuleCount; moduleID++ ))
    do
        umModuleIP1=$(xmllint --xpath "string(//ModuleIPAddr$moduleID-1-2)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        umModuleIP2=$(xmllint --xpath "string(//ModuleIPAddr$moduleID-2-2)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        umModuleHostname1=$(xmllint --xpath "string(//ModuleHostName$moduleID-1-2)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        umModuleHostname2=$(xmllint --xpath "string(//ModuleHostName$moduleID-2-2)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        if ssh -q -o "BatchMode yes" $REMOTE_USER@$umModuleIP1 exit; then
            umModuleIP[$moduleID]=$umModuleIP1
            umModuleHostname[$moduleID]=$umModuleHostname1
        elif ssh -q -o "BatchMode yes" $REMOTE_USER@$umModuleIP2 exit; then
            umModuleIP[$moduleID]=$umModuleIP2
            umModuleHostname[$moduleID]=$umModuleHostname2
        else
            echo "ERROR: cannot Connect to UM$moduleID" >&2
            echo "(IP1 = $umModuleIP1)" >&2
            echo "(IP2 = $umModuleIP2)" >&2
            detectError=true
        fi
    done

    for (( moduleID=1; moduleID<=$pmModuleCount; moduleID++ ))
    do
        pmModuleIP1=$(xmllint --xpath "string(//ModuleIPAddr$moduleID-1-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        pmModuleIP2=$(xmllint --xpath "string(//ModuleIPAddr$moduleID-2-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        pmModuleHostname1=$(xmllint --xpath "string(//ModuleHostName$moduleID-1-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        pmModuleHostname2=$(xmllint --xpath "string(//ModuleHostName$moduleID-2-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        
        if ssh -q -o "BatchMode yes" $REMOTE_USER@$pmModuleIP1 exit; then
            pmModuleIP[$moduleID]=$pmModuleIP1
            pmModuleHostname[$moduleID]=$pmModuleHostname1
        elif ssh -q -o "BatchMode yes" $REMOTE_USER@$pmModuleIP2 exit; then
            pmModuleIP[$moduleID]=$pmModuleIP2
            pmModuleHostname[$moduleID]=$pmModuleHostname2
        else
            echo "ERROR: Cannot connect to PM$moduleID" >&2
            echo "(IP1 = $pmModuleIP1)" >&2
            echo "(IP2 = $pmModuleIP2)" >&2
            detectError=true
        fi
        
        pmModuleDBRootCount[$moduleID]=$(xmllint --xpath "string(//ModuleDBRootCount$moduleID-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)     
    done
    
    if [ $serverTypeInstall == "2" ]; then
        umModuleCount=$pmModuleCount
        for (( moduleID=1; moduleID<=$umModuleCount; moduleID++ ))
        do
            umModuleIP[$moduleID]=${pmModuleIP[$moduleID]}
            umModuleHostname[$moduleID]=${pmModuleHostname[$moduleID]}     
        done
    fi
    if [ "$detectError" = true ]; then
        echo "Check that ssh and passwordless login are available." >&2
        exit 255 
    fi
    
elif [ $singleServerInstall == "y" ]; then
    
    for (( moduleID=1; moduleID<=$pmModuleCount; moduleID++ ))
    do
        pmModuleDBRootCount[$moduleID]=$(xmllint --xpath "string(//ModuleDBRootCount$moduleID-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)      
    done
    umModuleCount=1
    umModuleIP[1]=$PM1
    pmModuleIP[1]=$PM1
       
else
    echo "Unknown install type = $installType" >&2
    exit 2
fi

}

measureDiskSpace () {
    for (( moduleID=1; moduleID<=$pmModuleCount; moduleID++ ))
    do
        for (( moduleDBRootID=1; moduleDBRootID<=${pmModuleDBRootCount[$moduleID]}; moduleDBRootID++ ))
        do
            thisDBrootID=$(xmllint --xpath "string(//ModuleDBRootID$moduleID-$moduleDBRootID-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
            command="ssh $REMOTE_USER@${pmModuleIP[$moduleID]} du -s -b ${DBRoot[$thisDBrootID]}"
            verbosePrint "$command"
            commandReturn=$($command)
            returnValues=($commandReturn)
            if [ ${returnValues[1]} == ${DBRoot[$thisDBrootID]} ]; then
                totalDiskSpaceNeeded=$(( $totalDiskSpaceNeeded + ${returnValues[0]} ))
                totalDiskSpaceNeededPM=$(( $totalDiskSpaceNeededPM + ${returnValues[0]} ))                
            else
                echo "failed return from command: $command" >&2
                exit 2
            fi
        done        
    done
    for (( moduleID=1; moduleID<=$pmModuleCount; moduleID++ ))
    do
        command="ssh $REMOTE_USER@${umModuleIP[$moduleID]} du -s -b $INSTALL_DIR/mysql/db"
        commandReturn=$($command)
        returnValues=($commandReturn)
        if [ ${returnValues[1]} == $INSTALL_DIR/mysql/db ]; then
            totalDiskSpaceNeeded=$(( $totalDiskSpaceNeeded + ${returnValues[0]} ))
            totalDiskSpaceNeededUM=${returnValues[0]}               
        else
            echo "failed return from command: $command" >&2
            exit 2
        fi
    done
    totalDiskSpaceAvailable=$(df -B1 $BACKUP_SERVER_LOCATION | awk 'NR==2 {print $4}')
}

###############################################################################
# monitorProgress
###############################################################################
monitorProgress () {
sizeOfData=$1
percentDone=0
oldSizeCopied=0
totalSizeCopied=0
printSeconds=0
printMinutes=0
printHours=0
sleepInt=5
loopCount=0
windowSize=5
stallCount=0
rsyncStalled=false
for (( winNum=0; winNum<$windowSize; winNum++ ))
do
    transferDiffs[$winNum]=0
done
while [ $percentDone -lt 99 ]
do
    cmdRtn=$(du -s -b $BACKUP_SERVER_LOCATION 2>/dev/null)
    returnValues=($cmdRtn)
    if [ ${returnValues[1]} == $BACKUP_SERVER_LOCATION ]; then
        oldSizeCopied=$totalSizeCopied
        totalSizeCopied=${returnValues[0]}
        if (( $oldSizeCopied == 0 )); then
            oldSizeCopied=$totalSizeCopied
        fi
    fi
    # Compute the percentage.
    percentDone=$(( $(( $totalSizeCopied * 100 )) / $sizeOfData ))
    # Compute the number of blocks to represent the percentage.
    if [ $percentDone -gt 99 ]; then
        break
    fi
    numberSymbols=$(( percentDone / 4 ))
    # Create the progress bar string.
    bar="Progress ["
    for (( num=0; num<=25; num++ ))
    do
        if (( $num < $numberSymbols )); then
            bar=$bar"="
        elif (( $num == $numberSymbols )); then
            bar=$bar">"
        else
            bar=$bar" "
        fi
    done

    # Print the progress bar.
    diff=$(( $totalSizeCopied - $oldSizeCopied )) 

    if (( $diff > 0 )); then   
        remainingCopy=$(( $sizeOfData - $totalSizeCopied ))
    else
        stallCount=$(( $stallCount + 1 ))
    fi
    
    winNum=$(( $loopCount % $windowSize ))
    transferDiffs[$winNum]=$diff
    totalDiffs=0
    for (( winNum=0; winNum<$windowSize; winNum++ ))
    do
        totalDiffs=$(($totalDiffs+${transferDiffs[$winNum]}))
    done
    averageDiffs=$(($totalDiffs / $windowSize))
    
    if (( $averageDiffs > 1000000 )); then
        rate=$(( $averageDiffs / 1000000 / $sleepInt ))" Mbps "
    elif (( $averageDiffs > 1000 )); then
        rate=$(( $averageDiffs / 1000 / $sleepInt ))" kbps "
    else
        rate=$averageDiffs" bits/second "
    fi
    
    if (( $averageDiffs > 0 )); then   
        remainingSeconds=$(( $remainingCopy / $(( $averageDiffs / $sleepInt )) ))
        printHours=$(( $remainingSeconds / 3600 ))
        printMinutes=$(( $(( $remainingSeconds % 3600 )) / 60 ))
        printSeconds=$(( $remainingSeconds % 60 ))
    else
        printSeconds=0
        printMinutes=0
        printHours=0
    fi
    
    bar=$bar"] ($percentDone%) $rate "
    line=$(printf "%02d:%02d:%02d %s" $printHours $printMinutes $printSeconds "Approx Time Remaining          ")
    echo -en "${bar}${line}\r"
    if [ $stallCount -gt 5 ]; then
        rsyncStalled=true;
        break
    fi
    sleep $sleepInt
    loopCount=$(($loopCount + 1))
done

if [ $rsyncStalled == false ]; then
    percentDone=100
    bar="Progress [=========================>] ($percentDone%) $rate "
    line=$(printf "%02d:%02d:%02d %s" $printHours $printMinutes $printSeconds "Approx Time Remaining          ")
    echo -en "${bar}${line}\n"
fi
}

###############################################################################
# Backup PM
###############################################################################
backupPMs () {
echo "Backing up PMs"
dir=$(mktemp -d)
## loop the pmModules
for (( moduleID=1; moduleID<=$pmModuleCount; moduleID++ ))
do
    for (( moduleDBRootID=1; moduleDBRootID<=${pmModuleDBRootCount[$moduleID]}; moduleDBRootID++ ))
    do
        thisDBrootID=$(xmllint --xpath "string(//ModuleDBRootID$moduleID-$moduleDBRootID-3)" $BACKUP_SERVER_LOCATION/Columnstore.xml)
        pmBackupDir="pm""$moduleID""dbroot""$moduleDBRootID"
        if [ ! -e $BACKUP_SERVER_LOCATION/$pmBackupDir ]; then
            mkdir $BACKUP_SERVER_LOCATION/$pmBackupDir
        fi
        echo "Backing up $pmBackupDir"
        moveBackupFiles $pmBackupDir ./backup.1/
        # Launch it in background
        executeRsyncBackground $DRY_RUN /$dir/$pmBackupDir --link-dest=../backup.1/$pmBackupDir $REMOTE_USER@${pmModuleIP[$moduleID]}:${DBRoot[$thisDBrootID]} $BACKUP_SERVER_LOCATION/$pmBackupDir
    done        
done

waitRsyncBackground $totalDiskSpaceNeededPM $dir
rm -rf "$dir"
echo -e "\nDONE"
}

###############################################################################
# Backup UM
###############################################################################
backupUM () {
echo "Backing up UM"
## dir=$(mktemp -d)
## loop the pmModules
for (( moduleID=1; moduleID<=$umModuleCount; moduleID++ ))
do
    umBackupDir="um""$moduleID"
    if [ ! -e $BACKUP_SERVER_LOCATION/$umBackupDir ]; then
        mkdir $BACKUP_SERVER_LOCATION/$umBackupDir
    fi
    
    echo "Backing up $umBackupDir"
    moveBackupFiles $umBackupDir ./backup.1/
    # Launch it in background
    executeRsync $DRY_RUN --link-dest=../backup.1/$umBackupDir $REMOTE_USER@${umModuleIP[$moduleID]}:$INSTALL_DIR/mysql/db $BACKUP_SERVER_LOCATION/$umBackupDir
done

#waitRsyncBackground $totalDiskSpaceNeededUM $dir
echo -e "\nDONE"
}


backupCnf () {
backupCnfDir="cnf"
if [ ! -e $BACKUP_SERVER_LOCATION/$backupCnfDir ]; then
    mkdir $BACKUP_SERVER_LOCATION/$backupCnfDir
fi
moveBackupFiles $backupCnfDir ./backup.1/

executeRsync $DRY_RUN --link-dest=../backup.1/$backupCnfDir $REMOTE_USER@$PM1:$INSTALL_DIR/mysql/my.cnf $BACKUP_SERVER_LOCATION/$backupCnfDir/
executeRsync $DRY_RUN --link-dest=../backup.1/$backupCnfDir $REMOTE_USER@$PM1:$INSTALL_DIR/mysql/my.cnf.d $BACKUP_SERVER_LOCATION/$backupCnfDir/
}


###############################################################################
# suspendDBWrites
###############################################################################
suspendDBWrites () {
if [ "$DRY_RUN" = false ]; then
    if [ "$VERBOSE" = true ]; then
        ssh $REMOTE_USER@$PM1 $INSTALL_DIR/bin/mcsadmin suspendDatabaseWrites y
    else
        echo "Suspend DB Writes"
        ssh $REMOTE_USER@$PM1 $INSTALL_DIR/bin/mcsadmin suspendDatabaseWrites y > /dev/null
    fi
fi
}


###############################################################################
# resumeDBWrites
###############################################################################
resumeDBWrites () {
if [ "$DRY_RUN" = false ]; then
    if [ "$VERBOSE" = true ]; then
        ssh $REMOTE_USER@$PM1 $INSTALL_DIR/bin/mcsadmin resumeDatabaseWrites y
    else
        echo "Resume DB Writes"
        ssh $REMOTE_USER@$PM1 $INSTALL_DIR/bin/mcsadmin resumeDatabaseWrites y > /dev/null
    fi
fi    
}

###############################################################################
# Main Execution
###############################################################################
main () {

if [ "$DRY_RUN" = false ]; then
    rotateBackups
fi

## Get the system info from xml file
getSystemInfo

## Debug Prints
verbosePrint ""
verbosePrint "Configuration:"
verbosePrint ""
verbosePrint "Server PM1 address = $PM1"
verbosePrint "Backup Server location = $BACKUP_SERVER_LOCATION"
verbosePrint "SystemName: $systemName"
verbosePrint "SingleServerInstall: $singleServerInstall"
verbosePrint "serverTypeInstall:  $serverTypeInstall"
verbosePrint "PMwithUM:  $PMwithUM"
verbosePrint "DBRootStorageType: $DBRootStorageType"
verbosePrint ""
verbosePrint "UMs: $umModuleCount"
verbosePrint "PMs: $pmModuleCount"
for (( moduleID=1; moduleID<=$umModuleCount; moduleID++ ))
do
    verbosePrint "um$moduleID ip ${umModuleIP[$moduleID]}"
    verbosePrint "um$moduleID host ${umModuleHostname[$moduleID]}"
    verbosePrint ""
done

for (( moduleID=1; moduleID<=$pmModuleCount; moduleID++ ))
do
    verbosePrint "pm$moduleID ip ${pmModuleIP[$moduleID]}"
    verbosePrint "pm$moduleID host ${pmModuleHostname[$moduleID]}"
    verbosePrint "pm$moduleID DBRootCount: ${pmModuleDBRootCount[$moduleID]}"
    verbosePrint ""
done

verbosePrint "DBRootCount: $DBRootCount"
for (( dbRootID=1; dbRootID<=$DBRootCount; dbRootID++ ))
do
    verbosePrint "DBRoot$dbRootID: ${DBRoot[$dbRootID]}"
done

## Check if xmllint is available for use


## Measure disk space usage and compare to available
measureDiskSpace

#verbosePrint "totalDiskSpaceNeededPM:    $totalDiskSpaceNeededPM"
#verbosePrint "totalDiskSpaceNeededUM:    $totalDiskSpaceNeededUM"
#verbosePrint "totalDiskSpaceAvailable:   $totalDiskSpaceAvailable"

if (( $totalDiskSpaceAvailable < $totalDiskSpaceNeeded )); then
    echo "ERROR: Not enough space on backup system" >&2
    echo "(Needs = $totalDiskSpaceNeeded)" >&2
    echo "(Avail = $totalDiskSpaceAvailable)" >&2
    exit 3
fi

## suspend db writes
suspendDBWrites

backupCnf

backupPMs

backupUM

## resume db writes
resumeDBWrites

exit 0
}

###############################################################################
# RUN MAIN
###############################################################################
main

exit 0

